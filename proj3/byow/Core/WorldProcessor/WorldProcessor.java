package byow.Core.WorldProcessor;

import byow.Core.Constants.*;
import byow.Core.WorldGenerator.WorldGenerator;
import byow.Core.WorldStreamer;
import byow.TileEngine.TERenderer;
import byow.TileEngine.TETile;
import edu.princeton.cs.introcs.StdDraw;

import java.util.Arrays;

import static byow.Core.Constants.*;
import static byow.Core.WorldStreamer.*;


/**
 * A class for the input parser to parse the input string for executing various actions
 */
public class WorldProcessor {

    private enum GAME_MODE {
        NEWGAME, LOADGAME, UNDEFINED
    }

    private String input; // the input string for the saving purposes
    private GAME_MODE mode = GAME_MODE.UNDEFINED;
    private WorldGenerator wg = null;

    public WorldProcessor() {
        input = "";
    }

    public WorldProcessor(String init_input) { // not sure whether to support this ctor
        input = init_input;
    }

    /**
     * return the world generated by the world generator
     */
    public TETile[][] getWorld() {
        checkWorldExists();
        return wg.world();
    }

    /**
     * exercise the main implementation logic
     * @param source the input source, either via keyboard or via string for now
     * @param ter the tile renderer
     */
    public void processWorld(InputSource source, TERenderer ter) {
        // parse the first part of the inputs to get seed
        processFirstChar(source);

        // get the world
        if (mode == GAME_MODE.NEWGAME) {
            ter.seedScreen("");
            processNewGame(source, ter);
        }
        else if (mode == GAME_MODE.LOADGAME) {
            // load the world from the filepath
            String inputLoaded = WorldStreamer.load(DEFAULT_PATH);
            StringSource ss = new StringSource(inputLoaded);

            // must start with 'N' or 'n'
            if (ss.possibleNextInput()) {
                char firstChar = ss.getNextKey();
                if (firstChar != 'N' && firstChar != 'n') {
                    throw new IllegalStateException("Internal Error: The loaded file at "
                            + DEFAULT_PATH + " does not start with 'N' or 'n'.");
                }
            }
            else {
                throw new IllegalStateException("Internal Error: The loaded file at "
                        + DEFAULT_PATH + " is empty");
            }

            processNewGame(ss, null);
            if (source.type() == INPUT_SOURCE.STRING) { // may have more here
                processInteractionStatic(source);
            }
        }
        else {
            throw new IllegalStateException("Internal error: game mode not set. ");
        }

        // show the world
        checkWorldExists();
        ter.initialize(WIDTH, HEIGHT + HEIGHT_TOP);
        displayWorld(ter);

        // user interaction in the keyboard mode
        if (source.type() == INPUT_SOURCE.KEYBOARD) {
            processInteractionDynamic(ter);
        }


    }

    /**
     * processing the new game mode, including getting the seed and generating the world
     * @param source the input source, either via keyboard or via string for now
     * @param ter the tile renderer
     */
    private void processNewGame(InputSource source, TERenderer ter) {

        // get seed
        input = 'N' + input;
        String seed_input = "";
        long seed = -1;
        while (source.possibleNextInput()) {
            char c2 = source.getNextKey();
            if (c2 == 's' || c2 == 'S') { // stop sign
                if (seed_input.equals("")) {
                    System.out.println("You should enter a seed before pressing 'S'/'s'. Please retype. ");
                    continue;
                }
                seed = Long.parseLong(seed_input);
                seed_input += c2;
                break; // the only exit
            }
            else if (c2 >= '0' && c2 <= '9') { // is a number
                seed_input += c2;
                if (ter != null) {
                    ter.seedScreen(seed_input);
                }

            }
            else { // retype
                System.out.println("You should enter a number or 'S'/'s' but given " + c2 );
            }

        }

        input = input + seed_input; // add seed "string" + a "S" or "s"

        if (seed < 0) {
            throw new IllegalStateException("Something goes wrong in the seed processing. Please check. ");
        }

        // generate the world
        wg = new WorldGenerator(seed);
        wg.generate();

        if (source.type() == INPUT_SOURCE.STRING) { // may have more here
            processInteractionStatic(source);
        }

    }

    /**
     * Parse the inputs regarding the world generation:
     * First char: N/n - new game mode; L/l - load game mode; Q/q - quit game mode
     * get seed under new game mode (always ended with "S" or "s"),
     * load the input under load game mode,
     * exit under quit game mode
     * At the end, the seed string plus the final 'S'/'s' get added to the input variable
     * under new game mode
     * @return the seed, -1 if something goes wrong
     */
    private void processFirstChar(InputSource source) {
        // usually call with empty string

        // first char
        char c;
        if (!source.possibleNextInput()) { // shall not reach here if the parts calling it is properly written
            throw new IllegalStateException("Missing the main menu action (N/L/Q)!");
        }
        while (source.possibleNextInput()) { // loop once if users type everything correctly
            c = source.getNextKey();
            switch (c) {
                case 'N' : case 'n' :
                    mode = GAME_MODE.NEWGAME;
                    return;
                case 'L' : case 'l' :
                    mode = GAME_MODE.LOADGAME;
                    return;
                case 'Q' : case 'q' :
                    System.out.println("You're about to exit without doing anything. ");
                    System.exit(0);
                default: // only under this case the loop will go on
                    System.out.println("Bad main menu operations! You're only allowed to enter N/L/Q");
            }
        }
    }

    // process the inputs regarding the interaction

    /**
     * process the interaction with static inputs, i.e. do not display anything with the user
     * @param source the input source, typically via string
     */
    public void processInteractionStatic(InputSource source) {
        checkWorldExists();
        char c;
        char lastChar = ' ';
        while (source.possibleNextInput()) {
            c = source.getNextKey();
            if (processKeyInteraction(c, lastChar, null)) {
                WorldStreamer.save(DEFAULT_PATH, input, true);
                break;
            }
            lastChar = c;
        }
    }

    /**
     * process the interaction with dynamic inputs, e.g. exercise the user keypress/mousepress
     * @param ter the tile renderer, used for displays to the user
     */
    public void processInteractionDynamic(TERenderer ter) {
        checkWorldExists();
        char c;
        char lastChar = ' ';
        while (true) { // note the difference
            if (StdDraw.isMousePressed()) { // mouse press
                int x = (int)StdDraw.mouseX();
                int y = (int)StdDraw.mouseY();
                processMouseInteraction(x, y, ter);
            }
            if (StdDraw.hasNextKeyTyped()) { // key press
                c = StdDraw.nextKeyTyped();
                if (processKeyInteraction(c, lastChar, ter)) {
                    WorldStreamer.save(DEFAULT_PATH, input, true);
                    break;
                }
                lastChar = c;
            }
        }
    }

    /**
     * Helper functions
     */

    // process interactions with mouse
    private void processMouseInteraction(int x, int y, TERenderer ter) {
        TETile[][] currentWorld = wg.world();
        ter.renderFrame(currentWorld, currentWorld[x][y].description());
    }

    // process interactions with keypress
    // return whether we should end the interaction
    private boolean processKeyInteraction (char c, char lastChar, TERenderer ter) {
        if (Arrays.binarySearch(MOVE_KEYPRESS, c) >= 0) { // a bit ugly
            input = input + c;
            wg.moveOneStep(DIRECTION.fromChar(c));
            if (ter != null) {
                displayWorld(ter);
            }
        }
        else if (lastChar == ':' && (c == 'Q' || c == 'q')) {
            return true;
        }

        return false;
    }

    // display the world
    private void displayWorld(TERenderer ter) {

        String msg = (wg.checkSucceed())? "Congratulations! You open the door!": "";
        ter.renderFrame(wg.world(), msg);
    }

    // make sure we generated the world before displaying it
    private void checkWorldExists() {
        if (wg == null) {
            throw new IllegalStateException("Internal error: World generator is not initialized yet.");
        }
    }

}
